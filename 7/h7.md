# H7
Tehtävänanto: Tero Karvinen, Lari Iso-Anttila, https://terokarvinen.com/sovellusten-hakkerointi/

## x)

> € Schneier 2015: Applied Cryptography, 20ed: Chapter 1: Foundations[^9]

- Terminology ("Historical Terms" loppuun)
    - Selkoteksti (plaintext) on ihmisluettavaa, joka voidaan salata salakirjoitusavaimella,
    (cipher) jolloin muodostuu salakirjoitusviesti (ciphertext).
    - M = message, E = encryption operator, D = decryption operator
    - edellisen perusteella käy järkeen, E(M) = salakirjoitettu viesti. D(E(M)) = selkoteksti
- Simple XOR
    - Tärkeitä noteja: a ^ a = 0, a ^ b ^ b = a
- Large Numbers
    - laitetaan fyysistä perspektiiviä siihen, kuinka suuria lukuja kirjassa
    käsitellään

> Karvinen 2024: Python Basics for Hackers[^8]

- Käytä interaktiivista python tulkkia
    - nopeampaa iterointia
- Jupiterilla (ipython3) voi tutkia tarkemmin funktion toimintaa "?" ja "??"
- Sisältää nopeat ohjeet tavujen manipulointiin, esim. ord, chr.


## Ratkaise CryptoPals Set 1 -haasteet

Cryptopals haasteiden linkki löytyy täältä[^1].

Kaikki tämä koodailu menee ihan lonkilta sen perusteella mitä arvaan, että kannattaa
tehdä. Pythonissa tiedän varsinkin, että jokaiselle for-loopille voisi kehittää
jonkin yhden rivin taikalauseen, mutta hankalempi luettava ellei näitä tee joka päivä.

Aina kannattaa alottaa perusteista, eli miten for-loop toimii. Sitten kun siihen
kyllästyy, niin voi alkaa kirjoittelee taikalauseita.

> This set is relatively easy. With one exception, most of these exercises should take only a couple minutes.

Jep jep..

## a)
> a) 1. Convert hex to base64.

Annettu sisääntulo on stringi hexana. Seuraavassa huomataan, että b64encode haluaa tavuja:
```python
>>> import base64 as b
>>> b.b64encode("hello world")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python3.12/base64.py", line 58, in b64encode
    encoded = binascii.b2a_base64(s, newline=False)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: a bytes-like object is required, not 'str'
>>> b.b64encode(b"hello world")
b'aGVsbG8gd29ybGQ='
```
Eli ensiksi pitää ainakin muuttaa annettu hexastring tavuiksi, ja sitten
vasta voidaan b64encodaa.
```python
import base64 as b

input = "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"
input_bytes = bytes.fromhex(input)
output = b.b64encode(input_bytes)

print(input_bytes)
print(output)
```
ja ajetaan:
```bash
$ python a.py
b"I'm killing your brain like a poisonous mushroom"
b'SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t'
```

## b)
> b) 2. Fixed XOR.

Tässä muutetaan molemmat annetut input sekä xor avain tavuiksi hexasta.
Sitten joku omakeksimä for-looppi ja pari print-debuggausta myöhemmin..
```python
import base64 as b

input = "1c0111001f010100061a024b53535009181c"
input_bytes = bytes.fromhex(input)
xor_key = "686974207468652062756c6c277320657965"
xor_key_bytes = bytes.fromhex(xor_key)

print(xor_key_bytes)
print(input_bytes)
output = ""
for i in range(len(xor_key_bytes)):
    a = xor_key_bytes[i]
    b = input_bytes[i]
    print(f'{a}^{b} = {a^b}')
    output += chr(a ^ b)

print(output)
```

ja tämän ulosanti:
```bash
$ python b.py
b"hit the bull's eye"
b'\x1c\x01\x11\x00\x1f\x01\x01\x00\x06\x1a\x02KSSP\t\x18\x1c'
104^28 = 116
105^1 = 104
116^17 = 101
32^0 = 32
116^31 = 107
104^1 = 105
101^1 = 100
32^0 = 32
98^6 = 100
117^26 = 111
108^2 = 110
108^75 = 39
39^83 = 116
115^83 = 32
32^80 = 112
101^9 = 108
121^24 = 97
101^28 = 121
the kid don't play
```

## c)
> c) 3. Single-byte XOR cipher.

Tämä olikin jo vähän helpompi nyt, kun opetteli taas pythonin syntaksia:
```python
import base64 as b

input = "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736"
input_bytes = bytes.fromhex(input)

for i in range(200): # arvataan, että varmaan jokin ekasta 200:sta merkistä on ollut avaimena
    output = ""
    for b in input_bytes:
        output += chr(b ^ i)
    print(f"XOR with {i}: {output}")
```

ja ulos:
```bash
$ python c.py > c.out.txt
$ vim c.out.txt # tarkastellaan ihan omin silmin..
...
XOR with 88: Cooking MC's like a pound of bacon
...
```

Lisätään vielä jokin järjestelmä outputin pisteytykselle, jottei tarvitse itse
etsiä. Annetaan pisteitä sen perusteella, kuuluuko kirjain ASCII taulukkoon[^2].
Ja vielä tarkemmin, kuuluuko kirjain välille A-Z tai a-z.

Tein vielä huvikseen pisteytysjärjestelmän siten, että kerätään kaikki tulokset,
mutta näytetään vain parhaiten pisteitä saaneet. Tällöin ei tarvitse erikseen vielä
asettaa mitään pisterajaa jolla näytetään tuloksia, näytetään vain parhaat.

```python
import base64 as b
from collections import defaultdict

input = "1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736"
input_bytes = bytes.fromhex(input)
outputs = defaultdict(list)

for i in range(200): # arvataan, että varmaan jokin ekasta 200:sta merkistä on ollut avaimena
    output = ""
    points = 0
    for b in input_bytes:
        char_out = b ^ i
        if (char_out >= 0x41 and char_out <= 0x5a) or (char_out >= 0x61 and char_out <= 0x7a):
            points += 1
        output += chr(char_out)
    outputs[points].append(f"XOR with {i}: {output}")

highest_points = max(outputs.keys())
print(f"best output(s): {outputs[highest_points]}")
```

```bash
$ python c.py
best output(s): ["XOR with 88: Cooking MC's like a pound of bacon", 'XOR with 120: cOOKING\x00mc\x07S\x00LIKE\x00A\x00POUND\x00OF\x00BACON']
```

Näistä selkein voittaja on XOR ASCII desimaalilla 88, hexalla 0x58.

## d)
> d) 4. Detect single-character XOR.

Tässä kohtaa alkoi jo pythoni muistua enemmän mieleen, niin for-loopit alkaa
näyttämään taiantekemiseltä. Olen siis koodaillut pythonilla jo ennen kuin
python3 on julkaistu (`print "hello world"` ftw).

Tehtävänanto sanoi, että edellisestä olisi hyötyä.. Ainakaan itsellä ei niinkään
ollut, sillä tuo pisteytysjärjestelmä piti kirjoittaa kokonaan uusiksi käyttämään
yleisten kirjainten perusteella annettuja pisteitä[^4].

```python
import base64 as b
from collections import defaultdict

input_list = open("4.txt").readlines()
input_list_bytes = [bytes.fromhex(line) for line in input_list]
top_outputs = {}
line = 0

# https://gist.github.com/pozhidaevak/0dca594d6f0de367f232909fe21cdb2f
# lisätty pikkukirjaimet myös suoraan
letterFrequency = {'E' : 12.0, 'T' : 9.10, 'A' : 8.12, 'O' : 7.68,
'I' : 7.31, 'N' : 6.95, 'S' : 6.28, 'R' : 6.02, 'H' : 5.92, 'D' : 4.32,
'L' : 3.98, 'U' : 2.88, 'C' : 2.71, 'M' : 2.61, 'F' : 2.30, 'Y' : 2.11,
'W' : 2.09, 'G' : 2.03, 'P' : 1.82, 'B' : 1.49, 'V' : 1.11, 'K' : 0.69,
'X' : 0.17, 'Q' : 0.11, 'J' : 0.10, 'Z' : 0.07, 'e' : 12.0, 't' : 9.10,
'a' : 8.12, 'o' : 7.68, 'i' : 7.31, 'n' : 6.95, 's' : 6.28, 'r' : 6.02,
'h' : 5.92, 'd' : 4.32, 'l' : 3.98, 'u' : 2.88, 'c' : 2.71, 'm' : 2.61,
'f' : 2.30, 'y' : 2.11, 'w' : 2.09, 'g' : 2.03, 'p' : 1.82, 'b' : 1.49,
'v' : 1.11, 'k' : 0.69, 'x' : 0.17, 'q' : 0.11, 'j' : 0.10, 'z' : 0.07 }

for input_bytes in input_list_bytes:
    outputs = defaultdict(list)
    for i in range(255):
        output = ""
        points = 0
        for b in input_bytes:
            char_out = b ^ i
            if chr(char_out) in letterFrequency.keys():
                points += letterFrequency[chr(char_out)]
            output += chr(char_out)
        outputs[points].append(f"XOR with {i}: {output}")
    highest_points = max(outputs.keys())
    top_outputs[line] = (highest_points, outputs[highest_points])
    line += 1

global_max = max(points for points, _ in top_outputs.values())
best_lines = [
    (line, outputs) for (line, (points, outputs)) in top_outputs.items()
    if points == global_max
]
print(f"best guess: {best_lines}")
```

```bash
$ python d.py
best guess: [(170, ['XOR with 21: nOW\x00THAT\x00THE\x00PARTY\x00IS\x00JUMPING*', 'XOR with 53: Now that the party is jumping\n'])]
```

## e)
> e) Vapaaehtoinen, suositeltava: 5. Implement repeating-key XOR.

Tämä oli vähän helpompi.

```python
import base64 as b
from collections import defaultdict

input = "Burning 'em, if you ain't quick and nimble \
        I go crazy when I hear a cymbal"
xor_key = "ICE"
output = ""
i = 0

for byte in input:
    #print(f"XOR {byte} ^ {xor_key[i%len(xor_key)]} : {chr(ord(byte) ^ ord(xor_key[i % len(xor_key)]))} : {ord(byte) ^ ord(xor_key[i % len(xor_key)])}")
    output += f"{ord(byte) ^ ord(xor_key[i % len(xor_key)]):02x}"
    i += 1

print(output)
```

Jätin koodiin debuggausprintin vielä, jos sitä kiinnostaa katsella. Tässäkin oli
apuna ASCII man-sivut[^2].

```bash
$ python e.py
0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f206963656963656963650063222663263b223f30633221262b690a652126243b632469203c24212425
```
## f)
> f) Vapaaehtoinen: 6. Break repeating-key XOR.

Aloitetaan tekemällä kuten ohjeistettu.

```
Write a function to compute the edit distance/Hamming distance between two strings.
The Hamming distance is just the number of differing bits. The distance between:
`this is a test`
and
`wokka wokka!!!`
is 37. Make sure your code agrees before you proceed.
```


Hamming distancesta riitti selostus jo
itse sivullakin, mutta luin hieman lisää Wikipediasta, jossa luki seuraavasti
> For binary strings a and b the Hamming distance is equal to the number of ones (population count) in a XOR b.[^3]

Wikipediassa vielä linkattiin suoraan lähteeseenkin tuossa, mutta tämä riitti jo
itselle siihen, että kokeilen tätä tapaa. Luodaan ensiksi `hamming_distance`:n
laskuri.

```python
def hamming_distance(byte_str1, byte_str2):
    distance = 0
    for i in range(len(byte_str1)): # oletus: str1 ja str2 samanpituiset
        xor_res = byte_str1[i] ^ byte_str2[i]
        bits = xor_res.bit_count()
        distance += bits
    return distance

str1 = b"this is a test"
str2 = b"wokka wokka!!!"
print(hamming_distance(str1, str2))
```

```bash
$ python f.py
37
```

Toimii siis. Seuraava osio.

> For each KEYSIZE, take the first KEYSIZE worth of bytes, and the second KEYSIZE worth of bytes, and find the edit distance between them. Normalize this result by dividing by KEYSIZE.

Seuraamalla ohjeita:

```python
for keysize in range(2, 41):
    str1 = input_decode[0:keysize]
    str2 = input_decode[keysize:2*keysize]
    dist = hamming_distance(str1, str2)
    print(f"keysize: {keysize}, distance: {dist}, normalized: {dist/keysize}")
```

ulosanti:
```bash
keysize: 2, distance: 5, normalized: 2.5
keysize: 3, distance: 6, normalized: 2.0
keysize: 4, distance: 14, normalized: 3.5
keysize: 5, distance: 6, normalized: 1.2
keysize: 6, distance: 24, normalized: 4.0
keysize: 7, distance: 21, normalized: 3.0
keysize: 8, distance: 24, normalized: 3.0
keysize: 9, distance: 32, normalized: 3.5555555555555554
keysize: 10, distance: 33, normalized: 3.3
keysize: 11, distance: 29, normalized: 2.6363636363636362
keysize: 12, distance: 39, normalized: 3.25
keysize: 13, distance: 33, normalized: 2.5384615384615383
keysize: 14, distance: 45, normalized: 3.2142857142857144
keysize: 15, distance: 44, normalized: 2.933333333333333
keysize: 16, distance: 48, normalized: 3.0
keysize: 17, distance: 50, normalized: 2.9411764705882355
keysize: 18, distance: 50, normalized: 2.7777777777777777
keysize: 19, distance: 63, normalized: 3.3157894736842106
keysize: 20, distance: 54, normalized: 2.7
keysize: 21, distance: 64, normalized: 3.0476190476190474
keysize: 22, distance: 82, normalized: 3.727272727272727
keysize: 23, distance: 73, normalized: 3.1739130434782608
keysize: 24, distance: 81, normalized: 3.375
keysize: 25, distance: 81, normalized: 3.24
keysize: 26, distance: 91, normalized: 3.5
keysize: 27, distance: 94, normalized: 3.4814814814814814
keysize: 28, distance: 99, normalized: 3.5357142857142856
keysize: 29, distance: 93, normalized: 3.206896551724138
keysize: 30, distance: 103, normalized: 3.433333333333333
keysize: 31, distance: 96, normalized: 3.096774193548387
keysize: 32, distance: 110, normalized: 3.4375
keysize: 33, distance: 108, normalized: 3.272727272727273
keysize: 34, distance: 113, normalized: 3.323529411764706
keysize: 35, distance: 114, normalized: 3.257142857142857
keysize: 36, distance: 123, normalized: 3.4166666666666665
keysize: 37, distance: 115, normalized: 3.108108108108108
keysize: 38, distance: 109, normalized: 2.8684210526315788
keysize: 39, distance: 129, normalized: 3.3076923076923075
keysize: 40, distance: 124, normalized: 3.1
```

Tässä viiden keysizella olisi selkeästi paras tulos.

> The KEYSIZE with the smallest normalized edit distance is probably the key. You could proceed perhaps with the smallest 2-3 KEYSIZE values. Or take 4 KEYSIZE blocks instead of 2 and average the distances.

Tästä kiinnostaisi ottaa esim. 4 blockia keysize kokoisia stringejä ja katsoa
näiden etäisyyksien keskiarvon normaalia. Samalla teen taas dictin, jossa olisi
esim. top 5 parasta vaihtoehtoa ettei tarvitse pitkää listaa lukea.

```python

key_dist = {}
for keysize in range(2, 41):
    str1 = input_decode[0:keysize]
    str2 = input_decode[keysize:2*keysize]
    str3 = input_decode[2*keysize:3*keysize]
    str4 = input_decode[3*keysize:4*keysize]
    distances = [
        hamming_distance(str1, str2),
        hamming_distance(str1, str3),
        hamming_distance(str1, str4),
        hamming_distance(str2, str3),
        hamming_distance(str2, str4),
        hamming_distance(str3, str4),
    ]
    dist_avg = sum(distances) / len(distances)
    normalized = dist_avg/keysize
    key_dist[keysize] = normalized
    print(f"keysize: {keysize}, normalized: {dist_avg/keysize}")

print("Best performers:")
best_five = sorted(key_dist, key=key_dist.get)[:5]
print(best_five)
```

```bash
$ python f.py
keysize: 2, normalized: 3.0
keysize: 3, normalized: 3.111111111111111
keysize: 4, normalized: 3.3333333333333335
keysize: 5, normalized: 2.9
...
keysize: 27, normalized: 3.3456790123456788
keysize: 28, normalized: 3.1547619047619047
keysize: 29, normalized: 2.7471264367816093
keysize: 30, normalized: 3.1777777777777776
...
Best performers:
[29, 5, 2, 24, 7]
```

> Now that you probably know the KEYSIZE: break the ciphertext into blocks of KEYSIZE length.

Tehdään `chunk_blocks` funktio, joka avustaa tässä
```python
def chunk_blocks(cipher, keysize):
    return [cipher[i:i+keysize] for i in range(0, len(cipher), keysize)]

blocks = defaultdict(list)
for ks in best_five:
    blocks[ks] = chunk_blocks(input_decode, ks)

```

nyt `blocks` on dict, joka sisältää kaikki `keysize` kokoiset blockit.

> Now transpose the blocks: make a block that is the first byte of every block, and a block that is the second byte of every block, and so on.

Tämän tekniikan nerous alkaa jo näkymään.. Testasin sitä tekemällä blockeja,
jotka sisältävät "abcde". Blockeja on 10 kpl
```python
# ymmärtämisen helpottamiseksi, tehdään yksi keysize kerrallaan
best = 5
blocks = chunk_blocks("abcde"*10, best)

def transpose_blocks(blocks, ks):
    cols = [[] for _ in range(ks)]
    for block in blocks:
        for i in range(ks):
            if i < len(block):
                cols[i].append(block[i])
    return cols

transposed_blocks = transpose_blocks(blocks, best)
print(f"{blocks}\n{transposed_blocks}")
```

```bash
['abcde', 'abcde', 'abcde', 'abcde', 'abcde', 'abcde', 'abcde', 'abcde', 'abcde', 'abcde']
[['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a'],
['b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'],
['c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c'],
['d', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd', 'd'],
['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e']]
```

Noniin, ainakin koodi toimii.

> Solve each block as if it was single-character XOR. You already have code to do this.

```python
for t_block in transposed_blocks:
    outputs = defaultdict(list)
    for i in range(255):
        output = ""
        points = 0
        for b in t_block:
            char_out = b ^ i
            if chr(char_out) in letterFrequency.keys():
                points += letterFrequency[chr(char_out)]
            output += chr(char_out)
        outputs[points].append(f"XOR with {i:02x} {chr(i)}")
    highest_points = max(outputs)
    print(f"best guess: {outputs[highest_points]}")
```

Tämä koodi jo antaa jotakuinkin luettavasti näkyviin, että sattumoisin tuo eka
keysize (29) mitä kokeiltiin, ON se vastaus tähän.

```bash
Best performers:
[29, 5, 2, 24, 7]
best guess: ['XOR with 54 T', 'XOR with 74 t']
best guess: ['XOR with 45 E', 'XOR with 65 e']
best guess: ['XOR with 52 R', 'XOR with 72 r']
best guess: ['XOR with 08 \x08', 'XOR with 28 (']
best guess: ['XOR with 49 I', 'XOR with 69 i']
best guess: ['XOR with 4e N', 'XOR with 6e n']
best guess: ['XOR with 41 A', 'XOR with 61 a']
best guess: ['XOR with 54 T', 'XOR with 74 t']
best guess: ['XOR with 4f O', 'XOR with 6f o']
best guess: ['XOR with 52 R', 'XOR with 72 r']
best guess: ['XOR with 00 \x00', 'XOR with 20  ']
best guess: ['XOR with 58 X', 'XOR with 78 x']
best guess: ['XOR with 1a \x1a', 'XOR with 3a :']
best guess: ['XOR with 00 \x00', 'XOR with 20  ']
best guess: ['XOR with 42 B', 'XOR with 62 b']
best guess: ['XOR with 52 R', 'XOR with 72 r']
best guess: ['XOR with 49 I', 'XOR with 69 i']
best guess: ['XOR with 4e N', 'XOR with 6e n']
best guess: ['XOR with 47 G', 'XOR with 67 g']
best guess: ['XOR with 00 \x00', 'XOR with 20  ']
best guess: ['XOR with 54 T', 'XOR with 74 t']
best guess: ['XOR with 48 H', 'XOR with 68 h']
best guess: ['XOR with 45 E', 'XOR with 65 e']
best guess: ['XOR with 00 \x00', 'XOR with 20  ']
best guess: ['XOR with 4e N', 'XOR with 6e n']
best guess: ['XOR with 4f O', 'XOR with 6f o']
best guess: ['XOR with 49 I', 'XOR with 69 i']
best guess: ['XOR with 53 S', 'XOR with 73 s']
best guess: ['XOR with 45 E', 'XOR with 65 e']
```

Näkyy, että sieltä muodostuu joku lause, mutta hieman virhettä ilmassa

> For each block, the single-byte XOR key that produces the best looking histogram is the repeating-key XOR key byte for that block. Put them together and you have the key.

```python
xor_key = ""

for t_block in transposed_blocks:
    outputs = defaultdict(list)
    for i in range(255):
        output = ""
        points = 0
        for b in t_block:
            char_out = b ^ i
            if chr(char_out) in letterFrequency.keys():
                points += letterFrequency[chr(char_out)]
            output += chr(char_out)
        outputs[points].append(i)
    highest_points = max(outputs)
    xor_key += chr(outputs[highest_points][0])

print(xor_key)
```

```bash
TEINATORXBRINGTHENOISE
```

Ei ihan vielä näytä hyvältä. Lisään vielä pisteytysjärjestelmään normaalit välimerkit.

```python
# tosi yleinen
letterFrequency[' '] = 15.0
# säälipisteet, ettei esim. ([{}])$^<|> valita näiden sijaan.
letterFrequency['.'] = 0.5
letterFrequency[','] = 0.5
letterFrequency['!'] = 0.5
letterFrequency['?'] = 0.5
letterFrequency["'"] = 0.5
letterFrequency["-"] = 0.5
```

Nyt uudestaan:
```bash
Terminator X: Bring the noise
```

Tadaa! Täysi koodi löytyy `f.py`:stä tässä repossa.

> g) Vapaaehtoinen: 7. AES in ECB mode.

ECB (Electronic Code Book) mode on helpoin rikkoa.[^5]

AESia ajetaan pythonilla PyCryptodomen kirjastolla samalla lukien suoraan
tuolta ohjeet, kuinka salauksen avaus menee.[^6]

Ubuntulla tuo cryptodomen asennus globaalisti:

```bash
$ sudo apt install python3-cryptodome
```

ja sitten sen kautta AES importtaus pythoniin:

```python
from Cryptodome.Cipher import AES
```

Tässä koko pätkä tähän tehtävään

```python
import base64 as b
from Cryptodome.Cipher import AES

input = open("7.txt").read()
input_decoded = bytes(b.b64decode(input))
key = b"YELLOW SUBMARINE"

cipher = AES.new(key, AES.MODE_ECB)
output = cipher.decrypt(input_decoded)

print(str(output))
```

```bash
$ python g.py
b"I'm back and I'm ringin' the bell \nA rockin' on the mike while ...
```

> h) Vapaaehtoinen: 8. Detect AES in ECB mode.

AES ECB:lla 16 tavun avain tuottaa aina saman 16 tavun salauksen/selkotekstin.

Otetaan tiedosto, avataan b64encode, jaetaan 16 tavun osiin.

```python
import base64 as b
from Cryptodome.Cipher import AES

input = open("8.txt").read()
input_decoded = bytes(b.b64decode(input))
blocks = [input_decoded[i:i+16] for i in range(0, len(input_decoded), 16)]

for block in blocks:
    print(block.hex())
```

katsotaan ulosantia, jotta saisi vähän ideaa

```bash
$ python h.py
f1ad74db8edff747746b4e79dfcf3cf1
a77adb4e7cf36d7de9fe5fe9dd39736d
5e73c75c6b471bd1b7b4d9cddff1bd3d
7b7f36f7addfe38dda6b9d7875a6b9d3
...
```

Sitten käytetään `Counter`ia[^7] laskemaan suoraan helposti `block`ien määrää
```python
counts = Counter(blocks)

for block, count in counts.most_common(5):
    print(f"{block.hex()}, count:{count}")
```
```bash
$ python h.py
>>> 34e9fe1f77977677af5cef8e1c776f37, count:4 <<<
f1ad74db8edff747746b4e79dfcf3cf1, count:1
a77adb4e7cf36d7de9fe5fe9dd39736d, count:1
5e73c75c6b471bd1b7b4d9cddff1bd3d, count:1
7b7f36f7addfe38dda6b9d7875a6b9d3, count:1
```

Tästäpä nyt sitten se, jota näkyy eniten voisi olla AES ECB salattu blokki.

# Lähteet
[^1]: Cryptopals, https://cryptopals.com/sets/1
[^2]: Linux man pages, ASCII, https://man7.org/linux/man-pages/man7/ascii.7.html
[^3]: Hamming Distance, Wikipedia, https://en.wikipedia.org/wiki/Hamming_distance
[^4]: Python dict with English letter frequency, https://gist.github.com/pozhidaevak/0dca594d6f0de367f232909fe21cdb2f
[^5]: The difference in five modes in the AES encryption algorithm, Shawn Wang, 2019, https://www.highgo.ca/2019/08/08/the-difference-in-five-modes-in-the-aes-encryption-algorithm/
[^6]: AES, https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html
[^7]: class collections.Counter, https://docs.python.org/3/library/collections.html#collections.Counter
[^8]: Python Basics for Hackers, Karvinen, 2024, https://terokarvinen.com/python-for-hackers/
[^9]: Schneier, Bruce. Applied Cryptography: Protocols, Algorithms, and Source Code in C. 20th Anniversary ed., Wiley, 2015.
